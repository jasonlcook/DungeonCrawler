@page "/"
@using BlazorDungeonCrawler.Shared.Enumerators;
@using BlazorDungeonCrawler.Shared.Responses;
@using BlazorDungeonCrawler.Shared.Interfaces;

@inject IJSRuntime JS
@inject IDungeonDataManager DungeonManager
@inject HttpClient Http

@if (rejectedCookie == false && foundCookie != null && foundCookie == false) {
    <div id="cookie-consent" class="alert alert-info alert-dismissible fade show" role="alert">
        Would you like a cookie?
        <button type="button" class="accept-policy close dungeon-button" @onclick="RejectCookies">
            Reject Cookie
        </button>
        <button type="button" class="accept-policy close dungeon-button" @onclick="AcceptCookies">
            Accept Cookie
        </button>
    </div>
}

@if (dungeon != null && dungeon.InCombat) {
    <div class="modal-dialog-container">
        <div class="modal-dialog">
            <div class="modal-dialog-title">TITLE</div>
            <div class="modal-dialog-body">BODY</div>
            <div class="modal-dialog-buttons">
                <button @onclick="MonsterFight" class="dungeon-button">Fight</button>
                <button @onclick="MonsterFlee" class="dungeon-button">Flee</button>
            </div>
        </div>
    </div>
}

<div id="play-area">
    <div id="dungeon">
        <div id="messages"></div>
        <div id="stage">
            @if (dungeon == null) {
                <div class="loading">
                    <img src="/images/tiles/blue/base_tile.png" />
                </div>
            } else {
                string colourClass = getColourClass(GetLevelDepth());

                var orderedTiles = GetTiles();

                if (orderedTiles != null) {
                    foreach (Tile tile in orderedTiles) {
                        <div class="hexagon-tile-group" data-row="@tile.Row" data-column="@tile.Column">
                            <div class="hexagon-tile @colourClass hexagon-tile-base"></div>

                            @if (tile.Hidden) {
                                <div class="hexagon-tile hexagon-tile-hidden"></div>
                            } else {
                                <div class="hexagon-tile @colourClass @GetTypeClass(tile.Type)"></div>

                                @if (!tile.Current) {
                                    <div class="hexagon-tile hexagon-for-of-war"></div>
                                }
                            }

                            @if (tile.Selectable) {
                                <div class="hexagon-tile @colourClass hexagon-tile-selectable">
                                    <span @onclick="@(() => SelectTile(tile.Id))"></span>
                                </div>
                            }

                            @if (tile.Monsters.Count > 0) {
                                foreach (Monster monster in tile.Monsters) {
                                    string monsterTop = $"{monster.ClientY}px";
                                    string monsterLeft = $"{monster.ClientX}px";

                                    <span class="monster-counter" style="top: @monsterTop; left: @monsterLeft;">
                                        <span class="monster-counter-health">
                                            @monster.Health
                                        </span>
                                    </span>
                                }
                            }
                        </div>
                    }
                }
            }
        </div>
    </div>
    <div class="button">
        <button id="advance" class="dungeon-button" disabled>Advance</button>
    </div>
    <div class="details">
        <div class="adventurer">
            <div class="level">
                <span class="label">Level</span>
                <span class="value" id="current-level">
                    @((MarkupString)dungeonDepth)
                </span>
            </div>
            <div class="stats">
                <div class="health">
                    <span class="label">Health</span>
                    <span class="value" id="current-health">
                        @((MarkupString)health)
                    </span>
                </div>
                <div class="damage">
                    <span class="label">Damage</span>
                    <span class="value" id="current-damage">
                        @((MarkupString)damage)
                    </span>
                </div>
                <div class="protection">
                    <span class="label">Protection</span>
                    <span class="value" id="current-protection">
                        @((MarkupString)protection)
                    </span>
                </div>
            </div>
            <div class="dice"></div>
        </div>
        <div id="log">
            @if (dungeon == null) {
                <div class="log-entry">
                    <span class="log-entry-message">loading.</span>
                </div>
            } else {
                List<Message> messages = dungeon.Messages.OrderBy(m => m.Index).OrderBy(m => m.Datestamp).ToList();

                foreach (Message message in messages) {
                    <div data-identity="@message.Id" class="log-entry">
                        <span class="log-entry-message">
                            @message.Text
                        </span>
                        @*
                //todo add log action
                <ol class="log-actions" hidden="hidden" style="display: none;">
                <li data-identity="8ad049f1-279c-4e8e-a616-f433ce005468"><span class="log-action-message">Health roll 9</span></li>
                <li data-identity="8b4b8c0d-6e86-42a2-a534-e8ae7af0b80a"><span class="log-action-message">Protection roll 3</span></li>
                <li data-identity="6692b01e-ac55-4441-86f8-02031116a569"><span class="log-action-message">Damage roll 6</span></li>
                </ol>
                *@
                    </div>
                }
            }
        </div>
    </div>
</div>

<div id="version">
    <span class="api-version">
        @((MarkupString)apiVersion)
    </span>
    <span class="client-version">Client V0.2.1</span>
</div>

@code {
    //Cookies
    bool? foundCookie = null;
    bool rejectedCookie = false;
    string cookieKeyId = "BlazorWebAppCookies-Id";

    Guid cookiePlaceholder = Guid.Empty;
    Guid cookieId = Guid.Empty;

    protected override void OnInitialized() {
        if (foundCookie == null) {
            CheckCookies();
        }
    }

    private async void AcceptCookies() {
        Guid dungeonId = cookiePlaceholder;

        if (dungeon != null && dungeon.Id != Guid.Empty) {
            dungeonId = dungeon.Id;
        }

        StoreCookie(dungeonId);

        await InvokeAsync(StateHasChanged);
    }

    private async void RejectCookies() {
        rejectedCookie = true;

        await InvokeAsync(StateHasChanged);
    }

    private string BakeCookie(string key, string value, double days) {
        string dateStamp = "";
        if (days > 0) {
            dateStamp = DateTime.Now.AddDays(days).ToUniversalTime().ToString("R");
        }

        return $"{key}={value}; expires={dateStamp}; path=/";
    }

    private async void CheckCookies() {
        string response = GetCookie();
        Dictionary<string, string> cookies = ParseCookieResponse(response);

        if (cookies.ContainsKey(cookieKeyId)) {
            foundCookie = true;

            if (Guid.TryParse(cookies[cookieKeyId], out cookieId)) {
                await WriteLog($"COOKIEID: {cookieId}");
            }
        } else {
            foundCookie = false;
        }
    }

    private Dictionary<string, string> ParseCookieResponse(string value) {
        Dictionary<string, string> cookies = new();

        if (!string.IsNullOrEmpty(value)) {
            string[] values = value.Split(';');

            string cookieKey, cookieValue;
            foreach (string val in values) {
                cookieKey = val.Substring(0, val.IndexOf('=')).Trim();
                cookieValue = val.Substring(val.IndexOf('=') + 1);
                cookies.Add(cookieKey, cookieValue);
            }
        }

        return cookies;
    }

    private async void StoreCookie(Guid dungeonId) {
        string safeDungeonId = dungeonId.ToString();
        string cookie = BakeCookie(cookieKeyId, safeDungeonId, 7);
        await SetCookie(cookie);
    }

    private async Task SetCookie(string cookie) {
        await JS.InvokeVoidAsync("eval", $"document.cookie = \"{cookie}\"");
    }

    private string GetCookie() {
        return ((IJSInProcessRuntime)JS).Invoke<string>("eval", $"document.cookie");
    }

    public async Task WriteLog(string message) {
        await this.JS.InvokeVoidAsync("console.log", message);
    }

    //Dungeon
    bool successfulLoad = false;

    Dungeon? dungeon = null;
    Tile? tile = null;

    string apiVersion = "API V0.0.0";

    string dungeonDepth = "0";

    string health = "0";
    string damage = "0";
    string protection = "0";

    bool advanceButtonDisabled = true;

    string tilesHtml = "";

    protected override async void OnAfterRender(bool firstRender) {
        if (dungeon == null) {
            if (cookieId != Guid.Empty) {
                dungeon = await DungeonManager.GetDungeon(cookieId);
            }

            if (dungeon == null || dungeon.Id == Guid.Empty) {
                dungeon = await DungeonManager.GenerateNewDungeon();
            }

            if (dungeon != null && dungeon.Id != Guid.Empty) {
                if (foundCookie == true && cookieId != dungeon.Id) {
                    StoreCookie(dungeon.Id);
                }

                apiVersion = $"API V{dungeon.ApiVersion}";

                bool updateSuccess = await updateValues();

                if (!updateSuccess) {
                    //todo report error on loading
                }
            } else {
                //todo report error on loading
            }
        }

        if (dungeon != null && successfulLoad != true) {
            try {
                successfulLoad = await JS.InvokeAsync<bool>("dungeon_crawler.main.startup", $"{{\"rows\": {dungeon.Level.Rows}, \"columns\": {dungeon.Level.Columns} }}");
                if (successfulLoad != true) {
                    await InvokeAsync(StateHasChanged);
                }
            } catch (Exception ex) {
                //todo: add way of stopping too may requestes
                await InvokeAsync(StateHasChanged);
            }
        }
    }

    private string getColourClass(int dungeonDepth) {
        switch (dungeonDepth) {
            case 1:
            case 2:
            case 3:
                return "hexagon-colour-red";
            case 4:
            case 5:
            case 6:
            case 7:
                return "hexagon-colour-blue";
            case 8:
                return "hexagon-colour-purple";
            case 9:
                return "hexagon-colour-green";
            case 10:
                return "hexagon-colour-pink";
        }

        return "hexagon-colour-unknown";
    }

    private string GetTypeClass(DungeonEvemts type) {
        switch (type) {
            case DungeonEvemts.Empty:
                return "hexagon-tile-empty";
            case DungeonEvemts.DungeonEntrance:
                return "hexagon-tile-entrance";
            case DungeonEvemts.StairsAscending:
                return "hexagon-tile-stairs-ascending";
            case DungeonEvemts.StairsDescending:
                return "hexagon-tile-stairs-descending";
            case DungeonEvemts.Fight:
                return "hexagon-tile-fight";
            case DungeonEvemts.FightWon:
                return "hexagon-tile-fight-won";
            case DungeonEvemts.FightLost:
                return "hexagon-tile-adventurer-death";
            case DungeonEvemts.Chest:
                return "hexagon-tile-chest";
            case DungeonEvemts.FoundWeapon:
                return "hexagon-tile-weapon";
            case DungeonEvemts.FoundProtection:
                return "hexagon-tile-protection";
            case DungeonEvemts.FoundPotion:
                return "hexagon-tile-potion";
            case DungeonEvemts.TakenWeapon:
                return "hexagon-tile-weapon";
            case DungeonEvemts.TakenProtection:
                return "hexagon-tile-protection";
            case DungeonEvemts.TakenPotion:
                return "hexagon-tile-potion";
            case DungeonEvemts.Macguffin:
                return "hexagon-tile-macguffin";
        }

        return "hexagon-tile-unknown";
    }

    private async Task SelectTile(Guid tileId) {
        if (dungeon != null && dungeon.Id != Guid.Empty && tileId != Guid.Empty) {
            tile = await DungeonManager.SelectDungeonTile(dungeon.Id, tileId);
            //update single tile
        } else {
            //todo: trap error
        }
    }

    private async Task<bool> MonsterFlee() {
        if (dungeon == null || dungeon.Id == Guid.Empty || dungeon.CombatTile == Guid.Empty) {
            //todo: report error
            return false;
        }

        dungeon = await DungeonManager.MonsterFlee(dungeon.Id, dungeon.CombatTile);
        bool updateSuccess = await updateValues();

        return true;
    }

    private async Task<bool> MonsterFight() {
        if (dungeon == null || dungeon.Id == Guid.Empty || dungeon.CombatTile == Guid.Empty) {
            //todo: report error
            return false;
        }

        dungeon = await DungeonManager.MonsterFight(dungeon.Id, dungeon.CombatTile);
        bool updateSuccess = await updateValues();

        return true;
    }

    private async Task<bool> updateValues() {
        if (dungeon == null || dungeon.Id == Guid.Empty) {
            throw new Exception("Dungeon response was badly formed.");
        }

        if (dungeon.Level == null || dungeon.Level.Id == Guid.Empty || dungeon.Level.Depth == 0) {
            throw new Exception("Dungeon Level response was badly formed.");
        }

        if (dungeon.Adventurer == null || dungeon.Adventurer.Id == Guid.Empty || dungeon.Adventurer.HealthBase == 0 || dungeon.Adventurer.DamageBase == 0 || dungeon.Adventurer.ProtectionBase == 0) {
            throw new Exception("Dungeon Adventurer response was badly formed.");
        }

        dungeonDepth = GetLevelDepth().ToString();

        health = GetAdventurerHealth();
        damage = GetAdventurerDamage();
        protection = GetAdventurerProtection();

        await InvokeAsync(StateHasChanged);

        return true;
    }

    private int GetLevelDepth() {
        if (dungeon == null || dungeon.Id == Guid.Empty) {
            throw new Exception("Dungeon response was badly formed.");
        }

        if (dungeon.Level == null || dungeon.Level.Id == Guid.Empty || dungeon.Level.Depth == 0) {
            throw new Exception("Dungeon Level response was badly formed.");
        }

        return dungeon.Level.Depth;
    }

    private string GetAdventurerHealth() {
        if (dungeon == null || dungeon.Id == Guid.Empty) {
            throw new Exception("Dungeon response was badly formed.");
        }

        if (dungeon.Adventurer == null || dungeon.Adventurer.Id == Guid.Empty || dungeon.Adventurer.HealthBase == 0 || dungeon.Adventurer.HealthInitial == 0) {
            throw new Exception("Dungeon Adventurer response was badly formed.");
        }

        return $"{dungeon.Adventurer.HealthBase.ToString()} / {dungeon.Adventurer.HealthInitial.ToString()}";
    }

    private string GetAdventurerDamage() {
        if (dungeon == null || dungeon.Id == Guid.Empty) {
            throw new Exception("Dungeon response was badly formed.");
        }

        if (dungeon.Adventurer == null || dungeon.Adventurer.Id == Guid.Empty || dungeon.Adventurer.DamageBase == 0) {
            throw new Exception("Dungeon Adventurer response was badly formed.");
        }

        return dungeon.Adventurer.DamageBase.ToString();
    }

    private string GetAdventurerProtection() {
        if (dungeon == null || dungeon.Id == Guid.Empty) {
            throw new Exception("Dungeon response was badly formed.");
        }

        if (dungeon.Adventurer == null || dungeon.Adventurer.Id == Guid.Empty || dungeon.Adventurer.ProtectionBase == 0) {
            throw new Exception("Dungeon Adventurer response was badly formed.");
        }

        return dungeon.Adventurer.ProtectionBase.ToString();
    }

    private List<Tile> GetTiles() {
        if (dungeon == null || dungeon.Id == Guid.Empty) {
            throw new Exception("Dungeon response was badly formed.");
        }

        if (dungeon.Level == null || dungeon.Level.Id == Guid.Empty || dungeon.Level.Depth == 0) {
            throw new Exception("Dungeon Level response was badly formed.");
        }

        return dungeon.Level.Tiles.OrderBy(t => t.Row).OrderBy(t => t.Column).ToList();
    }
}